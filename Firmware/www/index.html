 g, b)
        Color in the RGB color space
    Returns
    -------
    tuple (h, s, v)
        Color in the HSV color space
    """
    
    # Scale from 0 .. 255 to 0.0 .. 1.0
    (r, g, b) = rgb_color
    r = r / 255.0
    g = g / 255.0
    b = b / 255.0
    high = max(r, g, b)
    low = min(r, g, b)
    h, s, v = high, high, high

    d = high - low
    s = 0 if high == 0 else d/high

    if high == low:
        h = 0.0
    else:
        h = {
            r: (g - b) / d + (6 if g < b else 0),
            g: (b - r) / d + 2,
            b: (r - g) / d + 4,
        }[high]
        h /= 6

    return h, s, v

def hsv_to_rgb(hsv_color):
    """Converts colors from the HSV color space to the RGB color space.
    Parameters
    ----------
    hsv_color : tuple (h, s, v)
        Color in the HSV color space
    Returns
    -------
    tuple (r, g, b)
        Color in the RGB color space
    """
    
    # Scale from 0 .. 360, 0 .. 100, 0 .. 100 to 0.0 .. 1.0
    (h, s, v) = hsv_color
    h = h / 360.0
    s = s / 100.0
    v = v / 100.0

    i = math.floor(h*6)
    f = h*6 - i
    p = v * (1-s)
    q = v * (1-f*s)
    t = v * (1-(1-f)*s)

    r, g, b = [
        (v, t, p),
        (q, v, p),
        (p, v, t),
        (p, q, v),
        (t, p, v),
        (v, p, q),
    ][int(i%6)]
    
    r = math.trunc(255 * r)
    g = math.trunc(255 * g)
    b = math.trunc(255 * b)
    return r, g, b

def setManualControl(manual):
    neoPixelLock.acquire()
    try:
        if manual:
            logger.write('Switching to remote control')
        else:
            logger.write('Switching to animation control')
            
        manualControl = manual
    finally:
        neoPixelLock.release()
        
def randomColor():
    return hsv_to_rgb((random.randint(0, 360), 100, random.randint(5, 100)))
                      
def beginUpdate():
    global updating
    
    updating += 1

def formatPixel(pixel):
    return ''.join('{:02x}'.format(a) for a in pixel)
    
    #return pixel[0].to_bytes(1, "big").hex()+pixel[1].to_bytes(1, "big").hex()+pixel[2].to_bytes(1, "big").hex()

def formatPixels(pixels):    
    result = ''
    for pixel in pixels:
        if result != '':
            result += ','
        result += formatPixel(pixel)
        
    return '<' + result + '>'

def endUpdate():
    global updating
    
    if updating > 0:
        updating -= 1
        
    if updating == 0:
        neoPixels.write()
        
def setNeoPixel(neoPixelIndex, pixel):
    neoPixelLock.acquire()
    try:
        neoPixels[neoPixelIndex] = pixel
        if updating == 0:
            neoPixels.write()
    finally:
        neoPixelLock.release()

def setNeoPixels(pixels):
    neoPixelLock.acquire()
    try:
        neoPixelIndex = 0
        for pixel in pixels:            
            neoPixels[neoPixelIndex] = pixel
            neoPixelIndex += 1
            
        if updating == 0:
            neoPixels.write()
    finally:
        neoPixelLock.release()

def blendPixel(pixel1, pixel2, blend):
    result = [0, 0, 0]
    
    if blend < 0.0:
        blend = 0.0
    elif blend > 1.0:
        blend = 1.0
    
    for channel in range(3):
        result[channel] = math.trunc(pixel1[channel] * (1.0 - blend) + pixel2[channel] * blend)
        
    return result

def blendPixels(pixels1, pixels2, blend):
    result = [0, 0, 0]
    
    if blend < 0.0:
        blend = 0.0
    elif blend > 1.0:
        blend = 1.0
    
    result = [blendPixel(pixels1[i], pixels2[i], blend) for i in range(neoPixelCount)]
    
    return result

def Off():
    pixels = [[0,0,0]] * neoPixelCount
    setNeoPixels(pixels)
    
if __name__ == "__main__":
    logger.write("__main__: All pixels off")
    Off()
    
    